# javascript之闭包

## 闭包的概念
&#8194;&#8194;&#8194;&#8194;闭包（closure）是 JavaScript 的一种语法特性。

&#8194;&#8194;&#8194;&#8194;关于闭包，有一种经典的提法——“闭包是代码块和创建该代码块的上下文（环境）中数据的结合”。

&#8194;&#8194;&#8194;&#8194;闭包就是在函数内部定义函数，内部的函数可访问其外部函数的作用域。下面是在程序中实现闭包的例子。

```js
function outer(name){ // 外部的函数

 var msg="hello";
  function inner(){ // 内部函数
   alert(msg+" "+name);
  }
  return inner(); // 返回内部函数
 }
 var clos=outer("WANGERN");
 clos();
```

&#8194;&#8194;&#8194;&#8194;执行代码，将弹出警告“hello WANGERN”。


## 前提


&#8194;&#8194;&#8194;&#8194;要理解闭包，还有一个很关键性概念—— JavaScript 的作用域规则。先解释一下作用域（scope）。在运行函数都会创建属于函数的上下文环境（context）及作用域，作用域即当前环境范围内的变量。JavaScript 中最外围的环境为 window 对象，也就是全局作用域所在的环境。当执行到下一级环境时，下一级环境会主动包含上一级的作用域，最终形成一级一级关联的作用域链（对象的 \[\[Scope\]\] 属性指向该作用域链）。当有下一级环境生成时，上一级环境会失活，但不会自动销毁而保存在一种“栈”式结构中，这样可以保证作用域链的延续性，也可以环境回退时再次激活。当前环境可访问当前作用域链中的全部变量，比如上面代码中的 inner\(\) 函数可访问 outer\(\) 函数中的 msg 和 name 变量。 

&#8194;&#8194;&#8194;&#8194;闭包就是借助这种作用域链，一方面可使内部函数可访问外部函数的变量；另一方面，闭包还可以抑制外部函数环境的销毁，使其变量始终保存在内存中，直至不需要时再销毁。


---

## 闭包的实例

&#8194;&#8194;&#8194;&#8194;先看下面的例子，当function里嵌套function时，内部的function可以访问外部function里的变量。

 ```js
 function foo(x) {
     var tmp = 3;
     function bar(y) {
         alert(x + y + (++tmp));
     }
     bar(10);
 }
 foo(2)
 ```

&#8194;&#8194;&#8194;&#8194;不管执行多少次，都会alert 16，因为bar能访问foo的参数x，也能访问foo的变量tmp。

&#8194;&#8194;&#8194;&#8194;但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。


 ```js
 function foo(x) {
     var tmp = 3;
     return function (y) {
         alert(x + y + (++tmp));
     }
 }
 var bar = foo(2); // bar 现在是一个闭包
 bar(10);
 ```

&#8194;&#8194;&#8194;&#8194;上面的脚本最终也会alert 16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。

&#8194;&#8194;&#8194;&#8194;但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1.

&#8194;&#8194;&#8194;&#8194;\(我们其实可以建立不止一个闭包方法，比如return它们的数组，也可以把它们设置为全局变量。它们全都指向相同的x和相同的tmp，而不是各自有一份副本。\)

&#8194;&#8194;&#8194;&#8194;上面的x是一个字面值\(值传递\)，和JS里其他的字面值一样，当调用foo时，实参x的值被复制了一份，复制的那一份作为了foo的参数x。

&#8194;&#8194;&#8194;&#8194;那么问题来了，JS里处理object时是用到引用传递的，那么，你调用foo时传递一个object，foo函数return的闭包也会引用最初那个object！


 ```js
 function foo(x) {
 var tmp = 3;
 return function (y) {
     alert(x + y + tmp);
     x.memb = x.memb ? x.memb + 1 : 1;
     alert(x.memb);
     }
 }
 var age = new Number(2);
 var bar = foo(age); // bar 现在是一个引用了age的闭包
 bar(10);
 ```

&#8194;&#8194;&#8194;&#8194;不出我们意料，每次运行bar\(10\)，x.memb都会自加1。但需要注意的是x每次都指向同一个object变量——age，运行两次bar\(10\)后，age.memb会变成2.

&#8194;&#8194;&#8194;&#8194;这里有一个不用return关键字的闭包例子：


 ```js
 function closureExample(objID, text, timedelay) { 
     setTimeout(function() { 
         document.getElementById(objID).innerHTML = text; 
     }, timedelay); 
 } 
 closureExample(‘myDiv’, ‘Closure is created’, 500);
 ```


&#8194;&#8194;&#8194;&#8194;JS里的function能访问它们的：


1. 参数

2. 局部变量或函数

3. 外部变量（环境变量？），包括

   3.1 全局变量，包括DOM。

   3.2 外部函数的变量或函数。


&#8194;&#8194;&#8194;&#8194;如果一个函数访问了它的外部变量，那么它就是一个闭包。

&#8194;&#8194;&#8194;&#8194;注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。


&#8194;&#8194;&#8194;&#8194;一个典型的例子就是全局变量的使用。

&#8194;&#8194;&#8194;&#8194;从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。

&#8194;&#8194;&#8194;&#8194;闭包经常用于创建含有隐藏数据的函数（但并不总是这样）。


 ```js
 var db = (function() {
 // 创建一个隐藏的object, 这个object持有一些数据
 // 从外部是不能访问这个object的
 var data = {};
 // 创建一个函数, 这个函数提供一些访问data的数据的方法
 return function(key, val) {
     if (val === undefined) { return data[key] } // get
     else { return data[key] = val } // set
     }
 // 我们可以调用这个匿名方法
 // 返回这个内部函数，它是一个闭包
 })();
 
 db('x'); // 返回 undefined
 db('x', 1); // 设置data['x']为1
 db('x'); // 返回 1
 // 我们不可能访问data这个object本身
 // 但是我们可以设置它的成员
 ```


## 闭包的总结


&#8194;&#8194;&#8194;&#8194;(1) 闭包是一种设计原则，它通过分析上下文，来简化用户的调用，让用户在不知晓的情况下，达到他的目的；

&#8194;&#8194;&#8194;&#8194;(2) 网上主流的对闭包剖析的文章实际上是和闭包原则反向而驰的，如果需要知道闭包细节才能用好的话，这个闭包是设计失败的；




