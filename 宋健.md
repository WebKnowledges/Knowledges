# javascript之闭包

## 闭包的概念
&#8194;&#8194;&#8194;&#8194;闭包（closure）是 JavaScript 的一种语法特性。

&#8194;&#8194;&#8194;&#8194;关于闭包，有一种经典的提法——“闭包是代码块和创建该代码块的上下文（环境）中数据的结合”。

&#8194;&#8194;&#8194;&#8194;闭包就是在函数内部定义函数，内部的函数可访问其外部函数的作用域。下面是在程序中实现闭包的例子。

```js
function outer(name){ // 外部的函数

 var msg="hello";
  function inner(){ // 内部函数
   alert(msg+" "+name);
  }
  return inner(); // 返回内部函数
 }
 var clos=outer("WANGERN");
 clos();
```

&#8194;&#8194;&#8194;&#8194;执行代码，将弹出警告“hello WANGERN”。


## 前提


&#8194;&#8194;&#8194;&#8194;要理解闭包，还有一个很关键性概念—— JavaScript 的作用域规则。先解释一下作用域（scope）。在运行函数都会创建属于函数的上下文环境（context）及作用域，作用域即当前环境范围内的变量。JavaScript 中最外围的环境为 window 对象，也就是全局作用域所在的环境。当执行到下一级环境时，下一级环境会主动包含上一级的作用域，最终形成一级一级关联的作用域链（对象的 \[\[Scope\]\] 属性指向该作用域链）。当有下一级环境生成时，上一级环境会失活，但不会自动销毁而保存在一种“栈”式结构中，这样可以保证作用域链的延续性，也可以环境回退时再次激活。当前环境可访问当前作用域链中的全部变量，比如上面代码中的 inner\(\) 函数可访问 outer\(\) 函数中的 msg 和 name 变量。 

&#8194;&#8194;&#8194;&#8194;闭包就是借助这种作用域链，一方面可使内部函数可访问外部函数的变量；另一方面，闭包还可以抑制外部函数环境的销毁，使其变量始终保存在内存中，直至不需要时再销毁。


---

## 闭包的实例

&#8194;&#8194;&#8194;&#8194;先看下面的例子，当function里嵌套function时，内部的function可以访问外部function里的变量。

> ```js
> function foo(x) {
>     var tmp = 3;
>     function bar(y) {
>         alert(x + y + (++tmp));
>     }
>     bar(10);
> }
> foo(2)
> ```

&#8194;&#8194;&#8194;&#8194;不管执行多少次，都会alert 16，因为bar能访问foo的参数x，也能访问foo的变量tmp。

&#8194;&#8194;&#8194;&#8194;但，这还不是闭包。当你return的是内部function时，就是一个闭包。内部function会close-over外部function的变量直到内部function结束。


> ```js
> function foo(x) {
>     var tmp = 3;
>     return function (y) {
>         alert(x + y + (++tmp));
>     }
> }
> var bar = foo(2); // bar 现在是一个闭包
> bar(10);
> ```

&#8194;&#8194;&#8194;&#8194;上面的脚本最终也会alert 16，因为虽然bar不直接处于foo的内部作用域，但bar还是能访问x和tmp。

&#8194;&#8194;&#8194;&#8194;但是，由于tmp仍存在于bar闭包的内部，所以它还是会自加1，而且你每次调用bar时它都会自加1.

&#8194;&#8194;&#8194;&#8194;\(我们其实可以建立不止一个闭包方法，比如return它们的数组，也可以把它们设置为全局变量。它们全都指向相同的x和相同的tmp，而不是各自有一份副本。\)

&#8194;&#8194;&#8194;&#8194;上面的x是一个字面值\(值传递\)，和JS里其他的字面值一样，当调用foo时，实参x的值被复制了一份，复制的那一份作为了foo的参数x。

&#8194;&#8194;&#8194;&#8194;那么问题来了，JS里处理object时是用到引用传递的，那么，你调用foo时传递一个object，foo函数return的闭包也会引用最初那个object！


> ```js
> function foo(x) {
> var tmp = 3;
> return function (y) {
>     alert(x + y + tmp);
>     x.memb = x.memb ? x.memb + 1 : 1;
>     alert(x.memb);
>     }
> }
> var age = new Number(2);
> var bar = foo(age); // bar 现在是一个引用了age的闭包
> bar(10);
> ```

&#8194;&#8194;&#8194;&#8194;不出我们意料，每次运行bar\(10\)，x.memb都会自加1。但需要注意的是x每次都指向同一个object变量——age，运行两次bar\(10\)后，age.memb会变成2.

&#8194;&#8194;&#8194;&#8194;这里有一个不用return关键字的闭包例子：


> ```js
> function closureExample(objID, text, timedelay) { 
>     setTimeout(function() { 
>         document.getElementById(objID).innerHTML = text; 
>     }, timedelay); 
> } 
> closureExample(‘myDiv’, ‘Closure is created’, 500);
> ```


&#8194;&#8194;&#8194;&#8194;JS里的function能访问它们的：


1. 参数

2. 局部变量或函数

3. 外部变量（环境变量？），包括

   3.1 全局变量，包括DOM。

   3.2 外部函数的变量或函数。


&#8194;&#8194;&#8194;&#8194;如果一个函数访问了它的外部变量，那么它就是一个闭包。

&#8194;&#8194;&#8194;&#8194;注意，外部函数不是必需的。通过访问外部变量，一个闭包可以维持（keep alive）这些变量。在内部函数和外部函数的例子中，外部函数可以创建局部变量，并且最终退出；但是，如果任何一个或多个内部函数在它退出后却没有退出，那么内部函数就维持了外部函数的局部数据。


&#8194;&#8194;&#8194;&#8194;一个典型的例子就是全局变量的使用。

&#8194;&#8194;&#8194;&#8194;从技术上来讲，在JS中，每个function都是闭包，因为它总是能访问在它外部定义的数据。

&#8194;&#8194;&#8194;&#8194;闭包经常用于创建含有隐藏数据的函数（但并不总是这样）。


> ```js
> var db = (function() {
> // 创建一个隐藏的object, 这个object持有一些数据
> // 从外部是不能访问这个object的
> var data = {};
> // 创建一个函数, 这个函数提供一些访问data的数据的方法
> return function(key, val) {
>     if (val === undefined) { return data[key] } // get
>     else { return data[key] = val } // set
>     }
> // 我们可以调用这个匿名方法
> // 返回这个内部函数，它是一个闭包
> })();
> 
> db('x'); // 返回 undefined
> db('x', 1); // 设置data['x']为1
> db('x'); // 返回 1
> // 我们不可能访问data这个object本身
> // 但是我们可以设置它的成员
> ```


## 闭包的总结


&#8194;&#8194;&#8194;&#8194;(1) 闭包是一种设计原则，它通过分析上下文，来简化用户的调用，让用户在不知晓的情况下，达到他的目的；

&#8194;&#8194;&#8194;&#8194;(2) 网上主流的对闭包剖析的文章实际上是和闭包原则反向而驰的，如果需要知道闭包细节才能用好的话，这个闭包是设计失败的；




